package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/fs"
	"io/ioutil"
	"log"
	"os"
	"path"
	"regexp"
	"strings"
	"text/template"
	"unicode"

	"github.com/pkic/regions"

	"golang.org/x/text/runes"
	"golang.org/x/text/secure/precis"
	"golang.org/x/text/transform"
	"golang.org/x/text/unicode/norm"
	yaml "gopkg.in/yaml.v3"
)

var (
	// Some ISO 3166-2 region code are just numbers or meta data
	regionCodeFormat = regexp.MustCompile(`^[A-Z]{2}-[A-Z]{2,3}$`)

	// regionMapTemplate is a template that produces a Golang source code file in
	// the "util" package containing a single member variable, a map of strings to
	// `util.Regions`.
	regionMapTemplate = template.Must(template.New("regionMapTemplate").Parse(
		`// Code generated by go generate; DO NOT EDIT.
 // This file was generated by create-cc-map.
 package check

 var regionMap = map[string]struct{
	complete bool
	regions map[string]bool
}{
{{- range $cc, $country :=  . }}
	"{{ $cc }}": {
		complete: {{ $country.Complete }},
		regions: map[string]bool{
		  {{- range $name, $bool := $country.Regions }}
		  "{{ $name }}": true,
		  {{- end }}
		},
	},
{{- end }}
}`))
)

type country struct {
	Complete bool
	Regions  map[string]bool
}

func main() {
	if len(os.Args) != 3 {
		fmt.Printf("missing arguments, usage: `%s ./input-directory ./regions_map.go`\n", path.Base(os.Args[0]))
		os.Exit(1)
	}

	filename := os.Args[2]
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0664)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error updating regions map: %s\n", err)
		os.Exit(1)
	}
	defer f.Close()

	if err := renderRegionsMap(os.Args[1], f); err != nil {
		fmt.Fprintf(os.Stderr, "error updating regions map: %s\n", err)
		os.Exit(1)
	}
}

func renderRegionsMap(path string, writer io.Writer) error {
	// Get all ISO 3166-2 regions
	data, err := getData(path)
	if err != nil {
		return err
	}

	rm := make(map[string]country)
	for _, c := range data {
		countryRegions := country{
			Complete: c.Complete,
			Regions:  make(map[string]bool),
		}

		for _, region := range c.Regions {
			if regionCode := getISO3166RegionCode(region); regionCode != "" {
				countryRegions.Regions[regionCode] = true
				countryRegions.Regions[strings.TrimPrefix(regionCode, fmt.Sprintf("%s-", c.ISO3166))] = true
			}

			for _, name := range region.Names {
				countryRegions.Regions[prepareValue(name.Name)] = true

				norm, err := precisNormalization(name.Name)
				if err == nil && norm != name.Name {
					countryRegions.Regions[prepareValue(norm)] = true
				}

				// Include source values, which are set in meta-data normalization
				for _, source := range name.Sources {
					if source.Value != "" {
						countryRegions.Regions[prepareValue(source.Value)] = true

						norm, err := precisNormalization(source.Value)
						if err == nil && norm != source.Value {
							countryRegions.Regions[prepareValue(norm)] = true
						}
					}
				}
			}
		}

		rm[c.ISO3166] = countryRegions
	}

	// Render the region map to a buffer with the region data
	var buf bytes.Buffer
	if err := regionMapTemplate.Execute(&buf, rm); err != nil {
		return err
	}

	// format the buffer so it won't trip up the `gofmt_test.go` checks
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	// Write the formatted buffer to the writer
	_, err = writer.Write(formatted)
	if err != nil {
		return err
	}
	return nil
}

func getData(path string) ([]regions.Country, error) {
	files, err := fs.ReadDir(os.DirFS(path), ".")
	if err != nil {
		log.Fatal(err)
	}

	var data []regions.Country
	for _, f := range files {
		// Preserve existing data
		c := regions.Country{}
		currentData, err := ioutil.ReadFile(path + "/" + f.Name())
		if err != nil {
			log.Println(err)
			continue
		}

		err = yaml.Unmarshal(currentData, &c)
		if err != nil {
			log.Println(err)
			continue
		}

		data = append(data, c)
	}

	return data, nil
}

func getISO3166RegionCode(r *regions.Region) string {
	if code, ok := r.Codes["iso3166-2"]; ok {
		if regionCodeFormat.MatchString(code) {
			return code
		}
	}
	return ""
}

// remove hypens and change to captials
func prepareValue(s string) string {
	return strings.ToUpper(strings.Replace(s, "-", " ", -1))
}

// precisNormalization is used to allow comparing strings of different character sets.
//
// This function is using "PRECIS" (Preparation, Enforcement, and Comparison of Internationalized
// Strings in Application Protocols) as defined by RFC7564.
func precisNormalization(name string) (string, error) {
	profile := precis.NewIdentifier(
		precis.AdditionalMapping(func() transform.Transformer {
			return transform.Chain(norm.NFD, runes.Remove(runes.In(unicode.Mn)))
		}),
		precis.Norm(norm.NFC),
	)
	result, err := profile.String(name)
	if err != nil {
		return "", err
	}
	return result, nil
}

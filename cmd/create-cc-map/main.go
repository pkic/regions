package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/fs"
	"io/ioutil"
	"log"
	"os"
	"path"
	"regexp"
	"strings"
	"text/template"

	"github.com/pkic/regions"

	yaml "gopkg.in/yaml.v3"
)

var (
	// Some ISO 3166-2 region code are just numbers or meta data
	regionCodeFormat = regexp.MustCompile(`^[A-Z]{2}-[A-Z]{2,3}$`)

	// regionMapTemplate is a template that produces a Golang source code file in
	// the "util" package containing a single member variable, a map of strings to
	// `util.Regions`.
	regionMapTemplate = template.Must(template.New("regionMapTemplate").Parse(
		`// Code generated by go generate; DO NOT EDIT.
 // This file was generated by create-cc-map.
 package check

 var regionMap = map[string]struct{
	complete bool
	regions map[string]bool
}{
{{- range $cc, $country :=  . }}
	"{{ $cc }}": {
		complete: {{ $country.Complete }},
		regions: map[string]bool{
		  {{- range $name, $bool := $country.Regions }}
		  "{{ $name }}": true,
		  {{- end }}
		},
	},
{{- end }}
}`))
)

type country struct {
	Complete bool
	Regions  map[string]bool
}

func main() {
	if len(os.Args) != 3 {
		fmt.Printf("missing arguments, usage: `%s ./input-directory ./regions_map.go`\n", path.Base(os.Args[0]))
		os.Exit(1)
	}

	filename := os.Args[2]
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0664)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error updating regions map: %s\n", err)
		os.Exit(1)
	}
	defer f.Close()

	if err := renderRegionsMap(os.Args[1], f); err != nil {
		fmt.Fprintf(os.Stderr, "error updating regions map: %s\n", err)
		os.Exit(1)
	}
}

func renderRegionsMap(path string, writer io.Writer) error {
	// Get all ISO 3166-2 regions
	data, err := getData(path)
	if err != nil {
		return err
	}

	rm := make(map[string]country)
	for _, c := range data {
		countryRegions := country{
			Complete: c.Complete,
			Regions:  make(map[string]bool),
		}

		for _, region := range c.Regions {
			if regionCode := getISO3166RegionCode(region); regionCode != "" {
				countryRegions.Regions[regionCode] = true
				countryRegions.Regions[strings.TrimPrefix(regionCode, fmt.Sprintf("%s-", c.ISO3166))] = true
			}

			for _, name := range region.Names {
				countryRegions.Regions[strings.ToUpper(name.Name)] = true
			}
		}

		rm[c.ISO3166] = countryRegions
	}

	// Render the region map to a buffer with the region data
	var buf bytes.Buffer
	if err := regionMapTemplate.Execute(&buf, rm); err != nil {
		return err
	}

	// format the buffer so it won't trip up the `gofmt_test.go` checks
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	// Write the formatted buffer to the writer
	_, err = writer.Write(formatted)
	if err != nil {
		return err
	}
	return nil
}

func getData(path string) ([]regions.Country, error) {
	files, err := fs.ReadDir(os.DirFS(path), ".")
	if err != nil {
		log.Fatal(err)
	}

	var data []regions.Country
	for _, f := range files {
		// Preserve existing data
		c := regions.Country{}
		currentData, err := ioutil.ReadFile(path + "/" + f.Name())
		if err != nil {
			log.Println(err)
			continue
		}

		err = yaml.Unmarshal(currentData, &c)
		if err != nil {
			log.Println(err)
			continue
		}

		data = append(data, c)
	}

	return data, nil
}

func getISO3166RegionCode(r *regions.Region) string {
	if code, ok := r.Codes["iso3166-2"]; ok {
		if regionCodeFormat.MatchString(code) {
			return code
		}
	}
	return ""
}
